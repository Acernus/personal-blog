---
title: 短地址系统设计
categories:
 - 系统设计
tags:
---

当前很多营销短信或者信息会使用短地址，如 `http://t.cn/AXSwe12EW` 的形式，有效的降低了url 的长度。那么一个可靠的短地址系统应该如何设计呢？

# 方案设计

## 需求分析

- 地址尽可能的短
- 读请求远大于写请求
- 如需要自定义短地址，需要额外设计
- 长地址去重

## 短地址生成
目前网上流传的关于短地址生成的，主要包括以下几种：

### Hash
我们可以使用各类的 hash 算法，将 hash 值作为短地址的值，呼声较高的是 Redis 采用的 [MurmurHash](https://en.wikipedia.org/wiki/MurmurHash)，可以很大的程度上减少 Hash 冲突。如果有冲突发生，可以采用线性探测，如在 hash 值后添加特殊值，或者序号，以此来解决冲突。Hash 算法难免会发生一些冲突，如果数据量较大的情况下，hash 冲突的概率也会大幅增加。因此，数据量较大的短地址系统中都不建议采取此种方式。

### 发号器
发号器的方案是相对来说比较标准的做法。主要分为两部分：发号和转换。

- 发号。为了解决 Hash 冲突可能造成的问题，我们可以利用数据库的自增主键或者其他序列号如 snowflake，uuid 等方案，生成唯一的序号，这样每个地址都不会重复
- 转换。每个记录都有一条单独的记录，我们当然不能直接使用记录号，我们可以利用进制转换的思想，将序号转换为 N 进制，只要 N 足够大，那么表示一个数的长度就越短，目前流行的方案是转换为 62 进制，即由 0~9，a~z, A~Z 组成的数。这样的记录使用 7 位我们就能表示 62<sup>7</sup> 个数，足够存储海量的 url，当然你也可以根据个性化变化进制与位数。

通过以上的方案，我们就能唯一的记录一条短地址与原地址对应关系。

## 存储
基于上述需求，我们可以采用 MySQL + Redis 的形式。使用 MySQL 存储相关必要的信息，使用 Redis 进行缓存数据，以便快速读取。

MySQL 中我们可以创建以下几个域：

| id | short_url | real_url |
|---|---|---|
| primary key | index(optional) | index |

id 是 MySQL 中的自增主键，也是我们的短地址的序号；由于我们在查询时需要使用短地址找到对应的原地址，因此 `short_url` 可以加上索引优化查询，当然你也可以直接根据进制的转换，先计算出序号，然后直接根据主键去查询，可以减少索引的开销；如果说业务需要去重，即同一个长地址对应的短地址返回相同的时，需要根据真实的 url 去查询是否存在，此时就会出现一个问题，如果长地址特别长，也会影响索引的开销，因此我们可以引入 md5，计算长地址的摘要
，建立索引进行查询，以此降低索引的开销。当然你也可以不用管去重的问题，直接生成新的。

对于海量数据的情况，我们可以采用分库分表的形式，使用发号器按照号段进行发放：

![image](/assets/images/20190612/numbering.png)

通过以上形式可以进行简单的扩展。

## 架构

通过上述需求分析与设计，我们可以画出以下系统的架构图：

![image](/assets/images/20190612/design.png)

这也是一个比较简单的结构，其中有可能出现的问题包括：
- redis 多实例取值时，需要 hash 到 slot 去直接拿，采用 [一致性 hash](https://en.wikipedia.org/wiki/Consistent_hashing) 均摊负载
- 缓存更新可以切换为后台线程更新缓存，防止缓存的雪崩

综上所述，我们就设计了一个简易的短地址系统。